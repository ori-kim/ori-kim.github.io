---
title: Froxy - 빠르고 간편하게 Gist를 Clone
description: 부스트캠프 웹 ・ 모바일 9기 팀프로젝트 최종발표 장표입니다.
date: 2024-12-26T00:00:00
slug: boostcamp-team
---

> [!info] 읽기 전에 이해하면 좋은 단어들
>
> - [TastackQuery](https://tanstack.com/query/latest) : 비동기 상태 관리 라이브러리
> - [FSD(Feature-Sliced Design)](https://emewjin.github.io/feature-sliced-design/) : 프론트엔드 폴더 계층 구조
> - [MSW(Mock Service Worker)](https://mswjs.io/) : 브라우저 및 Node.js용 API 모킹 라이브러리
> - Lotus : 서비스에서 Github의 Gist와 1 대 1로 대응되는 단위 (블로그 서비스의 Post와 유사한 개념)
> - 루카스 : 부스트캠프에서 제공되는 학습 플랫폼

### 관련 블로그 포스팅

- [잘 알려진 UI 패턴을 통해 도메인 코드 응집하기](https://orik.me/posts/doing-well-known-uI-patterns)
- [Effective Query Key](https://orik.me/posts/effective-query-key)

### 개요

![](https://i.imgur.com/ctCDrOI.jpeg)

안녕하세요! 빠르고 간편하게 Gist를 클론하고 실행시켜주는 서비스인 Froxy 서비스의 발표를 맞은 FE 개발자 김민우입니다.

저희팀은 저와 나경님이 프론트, 현지님 준호님이 백엔드를 맡아 서비스를 개발했습니다.

그럼 발표 시작하겠습니다.

![](https://i.imgur.com/l1eKR7s.jpeg)

네이버 부스트 캠프에서는 개인의 기술적 성장은 물론 함께 자라기가 매우 중요합니다.

따라서 챌린지 과정에서 캠퍼 분들은 매일 동료의 코드를 확인하고 피드백을 남기는 활동을 하게 됩니다.

![](https://i.imgur.com/qbzdV7g.jpeg)

챌린지 과정에서 캠퍼들이 익숙하지 않은 루카스에서 자신의 그룹의 Gist 경로를 찾고, 이를 로컬에 clone 해 실행하는 과정이 필요합니다.

이 과정에서 그룹원의 Gist를 실행하기 위해 여러 가지 개발 환경 문제를 마주하게 됩니다.

![](https://i.imgur.com/y7TjPM6.jpeg)

저희는 이러한 반복적인 코드 확인, 실행 활동을 보다 쉽고 간편하게 사용할 수 있게 만들어, 캠퍼들로 하여금 코드 리뷰에 집중할 수 있는 환경을 만들고자 이 서비스를 만들게 되었습니다!

저희 서비스에 가장 핵심적인 시나리오를 소개해 보겠습니다.

![](https://i.imgur.com/qMSsZuZ.gif)

![searchLotus](https://github.com/user-attachments/assets/dae69c41-e732-48ed-87e7-cadf921271ca)

저희 서비스는 Github 로그인을 통해 빠르게 자신의 Gist를 업로드할 수 있습니다.

사용자는 적절한 타이틀과 태그를 통해 Gist를 게시할 수 있고 Gist를 선택해 확인하고 업로드할 수 있습니다.

또한 다른 사람이 올린 것들을 확인할 수 있습니다.

![runLotus](https://github.com/user-attachments/assets/ec4ac2bb-98e9-4e20-bfbc-6b64e91e0e5d)

로그인을 하지 않고도 캠퍼들이 미리 올린 Gist를 확인하고 입력값을 직접 입력해 실제 실행 결과를 바로 확인할 수 있습니다.

물론 다른 사람들이 미리 실행해 본 결과물들을 통해 확인할 수 있습니다.

![](https://i.imgur.com/JEbxjtx.jpeg)

이를 통해 캠퍼들이 과제 수행과 코드 리뷰에 있어 생산성을 높이고, 학습 과정에 더 몰입할 수 있도록 돕는 것을 Froxy의 서비스 목표로 정했습니다.

![](https://i.imgur.com/U1pHjB3.jpeg)

이러한 Froxy 서비스의 시나리오에서 저희가 생각한 기술적 핵심은 코드를 빠르게 실행할 수 있는 환경과 이를 사용자에게 효과적으로 전달할 수 있는 서비스였습니다.

![](https://i.imgur.com/8KbGcnG.jpeg)

Froxy 서비스의 프론트엔드에서는 캔버스나 차트, 3D 모델링 서비스처럼 복잡한 UI 로직이 별도로 존재하지 않았기 때문에

![](https://i.imgur.com/btULzsY.jpeg)

대부분의 프론트가 고민해야 할 효율적인 서버 상태 관리와 재사용, 유지 보수 용이한 프론트엔드 개발 환경을 핵심으로 가져가고자 했습니다.

![](https://i.imgur.com/vbcGgSa.jpeg)

저희가 그러한 프론트엔드 환경을 구성하기 위해 시도한 기술적 도전들은 다음과 같습니다.

![](https://i.imgur.com/umL9MTL.jpeg)

이 중 오늘 발표할 핵심적으로 저희가 고민하고 집중한 기술은 다음과 같습니다.

![](https://i.imgur.com/zp8pUZy.jpeg)

앞선 기술들을 통해서

도메인 모델을 통해 UI 코드와 비즈니스 코드를 효과적으로 격리한 경험

계층화와 구조화를 통해 유지 보수하기 좋은 환경을 만든 경험

이를 서버와 독립적으로 개발하고 오류 경계를 나누기 위한 경험을 소개하고자 합니다.

### 도메인 모델을 통한 비즈니스 코드 응집 경험

![](https://i.imgur.com/YnqJj9W.jpeg)

초기의 저희 프론트엔드 코드에는 그림처럼 UI로 사용하는 각각의 컴포넌트에 여러 가지 도메인 비즈니스 로직이 섞여있었습니다. 실제 저희의 예시를 들어 설명해 보겠습니다.

![](https://i.imgur.com/s30ALL5.jpeg)

Froxy에서는 유저의 Gist 코드를 보여주는 시나리오가 존재했습니다. 이때 지원하지 않는 확장자를 사용자에게 알려주는 UI가 필요했습니다.

![](https://i.imgur.com/KcGrbba.jpeg)

이를 위해서 구현한 `CodeViewer` 컴포넌트에서는 여러 가지 비즈니스 로직과 UI를 처리하기 위한 로직이 섞이게 되었습니다.

이런 비즈니스 로직을 여러 컴포넌트에서 사용하면서 변경에 대응하기 어려웠습니다.

![](https://i.imgur.com/akFaNO1.jpeg)

또한 개발에 급한 초기 상황에 같은 유형의 여러 가지 타입들을 선언하게 되고, 만약 API의 구조가 변경되거나 요구사항의 변경이 발생하면, 코드베이스 전체를 수정해야 했습니다.

이러한 문제를 해결하기 위해 저희는 Froxy에서 사용하는 각각의 도메인을 도메인 객체를 통해서 관리하고자 했습니다.

![](https://i.imgur.com/XrcUbqt.jpeg)

`CodeViewer` 컴포넌트에서는 그에 맞는 도메인 객체인 `CodeFileModel`을 통해 서버에서 받은 DTO를 프론트에서 사용하기 용이하게 가공하고, 필요한 비즈니스 로직들을 캡슐화할 수 있도록 구현했습니다.

![](https://i.imgur.com/sBaeEQX.jpeg)

덕분에  `CodeViewer` 컴포넌트는 기존의 비즈니스 코드와 UI 코드가 섞인 복잡한 컴포넌트가 아닌 비즈니스 코드는 전달받은 Model에서 관리하고 컴포넌트에서는 UI에 대한 로직만 처리할 수 있도록 했습니다.

![](https://i.imgur.com/MKcALkd.jpeg)

이제 저희는 `CodeFileModel`뿐만 아니라 저희가 소비하는 모든 도메인을 각각의 도메인 객체로 관리하고자 했습니다.

- Gist를 저장하는 단위인 Lotus
- Lotus를 실행하는 단위인 History
- 파일을 보여주는 CodeFile
- 사용자를 나타내는 User

비즈니스 도메인은 아니지만 페이지를 관리하는 `PageModel`도 있습니다. 각각의 도메인에 대해서 1:1로 대응되는 도메인 모델 객체들을 구현했습니다.

![](https://i.imgur.com/TQup6NH.jpeg)

이제는 도메인 모델 객체를 통해서 각각의 도메인 데이터를 관리하고 해당 도메인의 비즈니스 로직을 메서드를 통해 캡슐화했습니다.

덕분에 `CodeViewer`의 경우와 같이 더 이상 컴포넌트에서 비즈니스 로직을 선언하지 않고 컴포넌트에서는 UI와 관련된 로직만 사용할 수 있고, 모든 비즈니스 로직은 전달받은 도메인 객체가 관리할 수 있게 되었습니다.

![](https://i.imgur.com/O6CDYHg.jpeg)

만들어진 도메인 객체를 UI에서 효율적으로 재사용하기 위해 각각의 도메인 객체와 1 대 1로 대응되는 합성 컴포넌트를 구현하였습니다.

덕분에 개발자는 여러 가지 도메인이 섞인 UI를 선언적으로 작업할 수 있게 되었습니다.

![](https://i.imgur.com/GftTZsI.jpeg)

Froxy 서비스에서 사용자의 Lotus 목록을 카드 형식으로 보여주어야 했습니다.

이를 위해 Lotus 모델을 사용하는 Lotus 컴포넌트와 User 모델을 사용하는 User 컴포넌트를 합성해 다음과 같은 `LotusCard` 컴포넌트를 만들 수 있었습니다.

![](https://i.imgur.com/qu8BxW1.jpeg)

만약 기존 카드형 리스트가 아닌, 간단한 리스트 형식의 `LotusList`가 추가적으로 필요해진 상황을 가정해 보자면, 새로운 컴포넌트를 설계할 필요 없이 기존에 있었던 합성 컴포넌트를 적절한 위치에 배치해 주기만 하면 해결됩니다.

이를 통해 각 도메인 모델을 쉽고 선언적으로 UI에서 재활용할 수 있게 되었습니다.

![](https://i.imgur.com/J7mqqy2.jpeg)

### 계층・구조화를 통한 개발 환경 개선 경험

도메인 객체를 통해 비즈니스 코드를 응집하고 합성 컴포넌트를 통해 UI 재사용을 이뤄냈습니다. 

이제는 이를 활용해서 서버 전달받은 데이터부터 UI 까지 효과적인 플로우로 개발, 유지 보수할 수 있도록 하는 방법이 필요했습니다.

![](https://i.imgur.com/0Wm3OLN.jpeg)

따라서 저희는 다음과 같이 API, Query, Hook, UI 각 계층을 구분해 프론트엔드 코드를 계층적으로 추가, 유지보수 하도록 했습니다.

![](https://i.imgur.com/cVO6EQG.jpeg)

API 계층에서는 지금까지 만든 도메인 모델을 통해서 서버에서 받은 DTO를 필요한 도메인 모델로 합성하고 이를 반환합니다.

만약 서버에서 온 데이터에 문제가 있거나 비즈니스 코드에 문제가 생기면 이 계층에서 오류가 발생합니다.

![](https://i.imgur.com/vxdLaHF.jpeg)

Query 계층에서는 API 계층에서 만들어진 `fetch` 함수들을 통해 구조화 가능한 쿼리 옵션으로 만들어냅니다.

이때 저희는 구조화된 쿼리키를 효율적으로 사용하기 위해 `createQueryOptions`이라는 QueryFactory를 만들어 간편화 했습니다.

`createQueryOptions`는 각각의 API를 쿼리 키와 함수로 이루어진 쿼리 옵션 객체로 만들어 줍니다.

![](https://i.imgur.com/AxWN4jr.jpeg)

Hook 계층에서는 만들어진 Query 옵션이나 해당 Hook을 소비하는 UI에 맞는 로직을 작성합니다. 

만약 UI에 종속된 로직에 문제가 발생하면 이 계층에서 오류가 발생합니다.

![](https://i.imgur.com/H7Xqexc.jpeg)

UI 계층에서는 Hook 계층에서 만들어진 훅과 UI를 연결합니다.

만약 UI에 문제가 생기면 이 계층에서 오류가 발생합니다.

![](https://i.imgur.com/sbSvGld.png)

![](https://i.imgur.com/wtEsmZl.png)

저희 서비스의 예시를 들어 설명해 보겠습니다. 사용자의 Lotus 목록을 불러오는 상황에서 저희는 먼저 `LotusList`를 불러오는 API 코드를 구성합니다.

이때 API 계층에서 도메인 모델들을 반환합니다.

![](https://i.imgur.com/1PoidqJ.png)

이를 `createQueryOptions`을 통해 적절하게 쿼리 옵션을 구조화해 구성합니다.

![](https://i.imgur.com/ShwAeLh.png)

다음으로 실제 사용하는 컴포넌트에서 적절한 훅을 조합해 리스트 컴포넌트를 구성합니다.

![](https://i.imgur.com/uM9Q35g.png)

이를 페이지에서 사용합니다.

![](https://i.imgur.com/w4ICBfi.jpeg)

만약 특정 사용자의 `LotusList`를 가져오고자 하면 어떻게 해야 할까요? 처음부터 전부 구현해야 할까요?

![](https://i.imgur.com/3a5dwXI.jpeg)

이때는 U I계층과 Hook 계층이 재사용 가능하기 때문에 저희는 사용자의 `LotusList`를 반환하는 API 계층을 구현해 (`userQueryOptions`를) 주입하면 문제를 해결할 수 있습니다.

![](https://i.imgur.com/Edz2EER.jpeg)

이러한 과정을 통해서 저희는 각각의 계층을 독립적으로 구분해 재사용 가능한 계층을 쉽게 재사용하고 구현해야 하는 경계를 나눌 수 있었습니다.

또한 일관된 플로우로 개발을 할 수 있으며 각각의 계층에서 오류 경계를 나눌 수 있었습니다.

![](https://i.imgur.com/Tn1XXEg.jpeg)

이제 UI를 충분히 구현할 수 있게 되었으므로 저희는 각각 UI의 속성에 따라서 FSD 구조를 참고해 분리하고자 했습니다.

![](https://i.imgur.com/teaDSCY.jpeg)

도메인 모델에 대한 합성 컴포넌트는 API와 함께 `features` 계층에서 구성하고

![](https://i.imgur.com/29VIDqN.jpeg)

Hook과 UI가 합쳐진 각각의 독립된 위젯은 `widgets` 계층에서 구성하고

![](https://i.imgur.com/N2mSKkO.jpeg)

만들어진 widget들을 `pages` 계층에서 경계를 나눠 합성하도록 했습니다.

![](https://i.imgur.com/t3Flkwp.jpeg)

이때 각각의 widget들은 페이지에서 사용할 때 독립된 API와 도메인 UI들을 관리하고 있기 때문에 효율적으로 경계를 나눠줄 필요가 있었습니다.

저희는 `Errorboundary`와 `Suspense`를 도입해 각각의 위젯들을 페이지에서 독립적으로 로딩하고 오류를 체크하도록 설계했습니다.

![](https://i.imgur.com/JVx0e3E.jpeg)

만일 코드는 보이지만 히스토리에서 오류가 난다면 경계가 없었을 때는 사용자가 모든 페이지를 파악하기 어렵지만, 경계를 두면 히스토리에서 오류가 발생해도 사용자는 나머지 정보인 Lotus의 정보를 확인할 수 있게 됩니다.

![](https://i.imgur.com/bULKOWg.jpeg)

이를 `Errorboundary`와 `Suspense`를 통해서 실제 컴포넌트에서는 정상적인 렌더링 과정에서 발생하는 로직만을 관리하고 이에 대한 `Pending`, `Reject` UI는 컴포넌트 외부에서 선언해 각각의 상태를 선언적으로 관리할 수 있었습니다.

### 서버와 독립적인 개발 경험

![](https://i.imgur.com/8nzjorz.jpeg)

이렇게 만들어진 프론트엔드 개발을 위해서는 API 계층의 흐름이 매우 중요합니다.

하지만 백엔드 개발자도 충분한 검증과 빠른 실행 환경을 위해 개발에 바쁘기 때문에 프론트엔드에서는 서버의 실제 API 없이 독립적으로 개발할 수 있는 환경이 필요했습니다.

![](https://i.imgur.com/Hcg70ur.jpeg)

따라서 저희는 MSW를 도입해 API 모킹을 시도했습니다.

![](https://i.imgur.com/QbNIdkq.jpeg)

이때 정적인 데이터를 통해 모킹을 시도하면 사용자 시나리오를 충분히 검증하기 힘들어집니다.

미리 만들어두었던 도메인 모델의 DTO 타입들을 전달해 이를 CRUD 해주는 `MockRepository` 구현체를 통해서 마치 서버에서 실제 데이터가 전달되고 생성되는 환경을 구성하고자 했습니다.

![](https://i.imgur.com/gb5gaAa.jpeg)

![](https://i.imgur.com/lla25mc.jpeg)

덕분에 저희는 서버와의 API 연결시 트러블 슈팅이 적었고 API가 없는 개발 환경에서는 MSW를, API가 있는 배포 환경에서는 nest 서버와 마치 스위치를 껐다 켰다 하는 것 처럼 개발할 수 있었습니다.

![](https://i.imgur.com/OH61SMV.jpeg)

다시 한번 정리하자면 Froxy의 프론트엔드에서는

- 도메인 모델을 통해 UI 코드와 비즈니스 코드를 효과적으로 격리한 경험을 통해 작은 단위의 코드 재사용을 할 수 있었고
- 계층화와 구조화를 통해 유지 보수하기 좋은 환경을 만든 경험을 통해 추가 요구사항이나 리팩터링을 계층별로 구현할 수 있게 되었고
- 이를 서버와 독립적으로 개발하고 오류 경계를 나누어 프론트엔드와 백엔드가 병렬적으로 작업하고 쉽게 연결할 수 있는 환경을 통해

요구사항을 쉽게 해결하기 위한 노력들을 했고 이에대해 어느정도 이뤄낸 것 같습니다.

이를 통해 앞으로 리팩터링을 할 때 CS나 AI 도메인에 집중할 수 있고 일관된 개발 환경을 얻을 수 있을 것 같습니다.
